from pyradioconfig.calculator_model_framework.CalcManager import CalcManager
from pyradioconfig.calculator_model_framework.model_serializers.human_readable import Human_Readable
from pyradioconfig.calculator_model_framework.model_serializers.static_timestamp_xml import Static_TimeStamp_XML

from pyradioconfig.to_be_deprecated.rm_io import *

import os.path
import shutil



    
def print_phy_h_source_from_regs(phy_name, register_dict, source_lines, family): 
           
    source_lines.append('void SelectPhy_%s_%s_autogen(void);\n' % (phy_name, family))
    

def print_phy_c_source_from_regs(phy_name, register_dict, source_lines, family): 
           
    source_lines.append('void SelectPhy_%s_%s_autogen(void) {' % (phy_name, family))
    
    # Read the lines of a file into a name/value dictionary
    #
    for register_name in sorted(register_dict.keys()):
        (block, reg) = register_name.split('.')
        value = register_dict[register_name]

        # FW rename for consistency
        if block == 'RFCRC':
            block = 'CRC'

        # arrayed register rename for CMSIS TODO:MW
        if reg == 'IRCALCOEFWR0':
            reg = 'IRCALCOEFWR[0].IRCALCOEFWR'
        if reg == 'IRCALCOEFWR1':
            reg = 'IRCALCOEFWR[1].IRCALCOEFWR'
        if reg == 'FCD0':
            reg = 'FCD[0].FCD'
        if reg == 'FCD1':
            reg = 'FCD[1].FCD'
        if reg == 'FCD2':
            reg = 'FCD[2].FCD'
        if reg == 'FCD3':
            reg = 'FCD[3].FCD'
        
        # don't print sequencer registers for now
        if block == 'SEQ':
            continue
            
        # Don't print CRC or FRC registers either
        #if block == 'FRC':
            #continue
        if block == 'CRC':
            continue
            
        source_lines.append('    %s->%s = 0x%x;' % (block, reg, value))

    source_lines.append('}\n')


#
# This creates a C source file that includes an autogenerated inline
# subroutine for each phy that exists.  Inline code is used because
# the routine is only going to be called once, so an inline function
# won't generate extra code, and an inline function won't generate
# any code at all if it's not called.  An inline function is include
# file friendly.
#
def create_c_source(output_filename_h="efrtest_setup_autogen.h", output_filename_c="efrtest_setup_autogen.c", family="dumbo", phy_list=None):

    part_family = family
    part_rev = "A0"
    radio_configurator = CalcManager(part_family, part_rev)

    if phy_list is None:
        # Get PHYs to filter
        types_model = radio_configurator.create_modem_model_type()
        #filter_phy_groups = radio_configurator.get_sim_tests_phy_groups()
        #filter_phy_groups.extend(radio_configurator.get_non_functional_phy_groups())
        filter_phy_groups = radio_configurator.get_non_functional_phy_groups()

        # Filter out phys from list
        filtered_phys = radio_configurator.filter_out_phy_group_names(types_model, filter_phy_groups)
        phy_list = [x.name for x in filtered_phys]

    # Generate the enumerated values for PHY_Select_t
    source_lines_h = []
    source_lines_h.append('#ifndef _RADIO_CONFIG_%s_AUTOGEN_H_' % part_family.upper())
    source_lines_h.append('#define _RADIO_CONFIG_%s_AUTOGEN_H_' % part_family.upper())
    source_lines_h.append('')
    source_lines_h.append('/* superseded by radio_config_autogen.h')
    source_lines_h.append(' * but still needed to create overall PHY list per chip')
    source_lines_h.append('')
    source_lines_h.append('typedef enum {')
    for phy_name in sorted(phy_list):
        source_lines_h.append('    %s,' % phy_name)
    source_lines_h.append('  } PHY_Select_%s_t;' % part_family)
    source_lines_h.append('*/')
    source_lines_h.append('')
        
    source_lines_c = []
    source_lines_c.append('#include \"pg_%s.h\"' % part_family)
    source_lines_c.append('')

    for phy_name in sorted(phy_list):
        print("Generating C routine: {0}.{1}".format(part_family, phy_name))

        # call calculator to populate model
        model = radio_configurator.calculate_phy(phy_name)
        
        # Convert from a model to a dictionary of register information
        # and then print the dictionary of registers as source code
        rm = build_rm_object(model.part_family)
        register_dict = model_to_register_dict(model, rm)
        print_phy_h_source_from_regs(phy_name, register_dict, source_lines_h, part_family)
        print_phy_c_source_from_regs(phy_name, register_dict, source_lines_c, part_family)

    source_lines_h.append('#endif')

    # Now print the switch statement to select the appropriate phy
    source_lines_c.append('/* superseded by radio_config_autogen.h')
    source_lines_c.append(' * but still needed to create overall PHY list per chip')
    source_lines_c.append('')
    source_lines_c.append('int EFRTEST_SelectPhy_%s_autogen(PHY_Select_%s_t phySelect) {' % (part_family, part_family))
    source_lines_c.append('    switch (phySelect) {')
    for phy_name in sorted(phy_list):
        routine_name = 'SelectPhy_' + phy_name + '_' + part_family + '_autogen()'
        source_lines_c.append('        case %s:  %s;  break;'  % (phy_name.ljust(60), routine_name.ljust(80) ) )
    source_lines_c.append('        default:  return -1;')
    source_lines_c.append('    }')
    source_lines_c.append('    return 0;\n}')
    source_lines_c.append('*/')
    
    # Write the results to a file
    dir = os.path.dirname(output_filename_h)
    if not os.path.exists(dir):
        os.makedirs(dir)
    if os.path.exists(output_filename_h):
        os.remove(output_filename_h)
    outputfile = open(output_filename_h, 'w')
    for line in source_lines_h:
        outputfile.write('%s\n' % line)
    outputfile.flush()
    outputfile.close()
        
    # Write the results to a file
    dir = os.path.dirname(output_filename_c)
    if not os.path.exists(dir):
        os.makedirs(dir)
    if os.path.exists(output_filename_c):
        os.remove(output_filename_c)
    outputfile = open(output_filename_c, 'w')
    for line in source_lines_c:
        outputfile.write('%s\n' % line)
    outputfile.flush()
    outputfile.close()
        
    print("Finished!")


#
# This creates a C source file that includes an autogenerated inline
# subroutine for each phy that exists.  Inline code is used because
# the routine is only going to be called once, so an inline function
# won't generate extra code, and an inline function won't generate
# any code at all if it's not called.  An inline function is include
# file friendly.
#
def create_one_c_source(output_filename="efrtest_setup_autogen.h", family="dumbo", phy_name='', optional_inputs=None):

    part_family = family
    part_rev = "A0"
    radio_configurator = CalcManager(part_family, part_rev)

    # Generate the enumerated values for PHY_Select_t
    source_lines = []
    source_lines.append('/*')
    source_lines.append('typedef enum {')
    source_lines.append('    %s,' % phy_name)
    source_lines.append('  } PHY_Select_%s_t;' % part_family)
    source_lines.append('*/')

    print("Generating C routine for: %s" % phy_name)

    # call calculator to populate model
    model = radio_configurator.calculate_phy(phy_name, optional_inputs)

    # Convert from a model to a dictionary of register information
    # and then print the dictionary of registers as source code
    rm = build_rm_object(model.part_family)
    register_dict = model_to_register_dict(model, rm)
    print_phy_c_source_from_regs(phy_name, register_dict, source_lines, part_family)

    # Now print the switch statement to select the appropriate phy
    source_lines.append('static __INLINE int EFRTEST_SelectPhy_%s_autogen(PHY_Select_%s_t phySelect) {' % (part_family, part_family))
    source_lines.append('    switch (phySelect) {')

    routine_name = 'SelectPhy_' + phy_name + + '_' + part_family + '_autogen()'
    source_lines.append('        case %s:  %s;  break;'  % (phy_name.ljust(60), routine_name.ljust(80) ) )
    source_lines.append('        default:  return -1;')
    source_lines.append('    }')
    source_lines.append('    return 0;\n}\n')

    # Write the results to a file
    outputfile = open(output_filename, 'w')
    for line in source_lines:
        outputfile.write('%s\n' % line)
    outputfile.close()

    print("Finished!")

if __name__ == '__main__':
    create_one_c_source('PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA.h', 'panther', 'PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA')

    phy_overrides = dict()
    phy_overrides['base_frequency_hz'] = 2450000000  # for BLE
    phy_overrides['RAC_RXENSRCEN_SWRXEN'] = 1
    phy_overrides['MODEM_SYNC0_SYNC0'] = 0xBEEFbed6 #0x8e89bed6
    phy_overrides['FRC_WCNTCMP0_FRAMELENGTH'] = 0x0000001b

    create_one_c_source('PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA_w_inputs.h', 'panther', 'PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA', phy_overrides)


    # create_one_c_source('PHY_Bluetooth_LE_Viterbi_BLEIQDSA.h', 'panther', 'PHY_Bluetooth_LE_Viterbi_BLEIQDSA')
    # create_one_c_source('PHY_IEEE802154_2p4GHz_cohdsa.h', 'panther', 'PHY_IEEE802154_2p4GHz_cohdsa')
